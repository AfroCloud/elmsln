<?php
/**
 * @file
 * Code for the CIS Service RestWS feature.
 */

include_once 'cis_service_restws.features.inc';

/**
 * Alter the outgoing response.
 *
 * @param mixed $response
 *   The response data being returned by the REST service (not yet serialized).
 * @param string $function
 *   The function being called on the REST service.
 * @param string $format_name
 *   The name of the format serializing the response.
 *
 * related issue https://drupal.org/node/2024603
 */
function cis_service_restws_restws_response_alter(&$response, $function, $format_name, $resourceController) {
  // specific modifications based common request type
  if (($function == 'viewResource' || $function == 'queryResource') && $format_name == 'json' && isset($_GET['deep-load-refs'])) {
    // query response is nested, direct access is not
    if ($function == 'queryResource') {
      foreach ($response['list'] as &$object) {
        _cis_service_restws_restws_deep_load($object);
      }
    }
    else {
      _cis_service_restws_restws_deep_load($response);
    }
    // @hack to convert json object to xml quickly and deliver
    // the page prior to drupal trying to do so
    if (isset($_GET['xml-out'])) {
      // figure out the entity type
      $arg0 = explode('.', arg(0));
      $entity = $arg0[0];
      // bump this up a level so its similar to .xml request method
      $response[$entity] = $response['list'];
      // unset the old
      unset($response['list']);
      // wrap the whole thing in a list
      print _cis_service_restws_getxml(array ('list' => $response));
      // set content type to XML so browser / others read it as XML
      drupal_add_http_header('Content-Type', 'application/xml');
      // end-cap and exit early this way we don't get the callback
      // that fires off traditional serialization
      drupal_page_footer();
      exit;
    }
  }
}

/**
 * Callback to perform deep load on a base entity
 *
 * @param $response
 *   response about to be sent back for the RestWS query
 * @return NULL
 *   this will load additional items into the response, filtering their
 *   fields based on account access to the deep loaded items.
 */
function _cis_service_restws_restws_deep_load(&$response) {
  // build list of allowed entity types to deep pull down
  $allowed = explode(',', $_GET['deep-load-refs']);
  // allow for deep loading of resources
  foreach ($response as $key => &$val) {
    // check for a single resource verses many
    if (is_array($val) && isset($val[0]['id'])) {
      // loop through items loading them in
      foreach ($val as &$item) {
        if (in_array($item['resource'], $allowed)) {
          // load the entity
          $entity = entity_load_single($item['resource'], $item['id']);
          // ensure they can view this specific item
          if (entity_access('view', $item['resource'], $entity)) {
            // create a meta wrapper to act on for entity
            $wrapper = entity_metadata_wrapper($item['resource'], $entity);
            // filter out these values
            $wrap = restws_property_access_filter($wrapper);
            $eary = (array) $entity;
            foreach ($eary as $property => $value) {
              // value needs to be removed as it didn't pass wrapper validation
              if (!isset($wrap[$property])) {
                unset($eary[$property]);
              }
            }
            // add values based on wrapper passing correctly
            $item = $eary;
          }
        }
      }
    }
    elseif (is_array($val) && isset($val['id'])) {
      if (in_array($val['resource'], $allowed)) {
        // load the entity
        $entity = entity_load_single($val['resource'], $val['id']);
        // ensure they can view this specific item
        if (entity_access('view', $val['resource'], $entity)) {
          // create a meta wrapper to act on for entity
          $wrapper = entity_metadata_wrapper($val['resource'], $entity);
          // filter out fields
          $wrap = restws_property_access_filter($wrapper);
          // typecast entity as array for property evaluation
          $eary = (array) $entity;
          foreach ($eary as $property => $value) {
            // value needs to be removed as it didn't pass wrapper validation
            if (!isset($wrap[$property])) {
              unset($eary[$property]);
            }
          }
          // add values based on wrapper passing correctly
          $val = $eary;
        }
      }
    }
  }
}

/**
 * Converts an array to XML
 *  http://www.devexp.eu/2009/04/11/php-domdocument-convert-array-to-xml/
 *  @param  <array> $array  The associative array you want to convert; nested numeric indices are OK!
 */
function _cis_service_restws_getxml( array $array ) {
  $array2XmlConverter  = new XmlDomConstructor('1.0', 'utf-8');
  $array2XmlConverter->xmlStandalone   = TRUE;
  $array2XmlConverter->formatOutput    = TRUE;
  try {
    $array2XmlConverter->fromMixed( $array );
    $array2XmlConverter->normalizeDocument ();
    $xml    = $array2XmlConverter->saveXML();
    return  $xml;
  }
  catch( Exception $ex )  {
    return  $ex;
  }
}

/**
 * Extends the DOMDocument to implement personal (utility) methods.
 * - From: http://www.devexp.eu/2009/04/11/php-domdocument-convert-array-to-xml/
 * - parent:: See http://www.php.net/manual/en/class.domdocument.php
 *
 * @throws   DOMException   http://www.php.net/manual/en/class.domexception.php
 *
 * @author Toni Van de Voorde
 */
class XmlDomConstructor extends DOMDocument {
  public function fromMixed($mixed, DOMElement $domElement = null) {
    $domElement = is_null($domElement) ? $this : $domElement;
    if (is_array($mixed)) {
      foreach ($mixed as $index => $mixedElement) {
        if ( is_int($index) ) {
          if ( $index == 0 ) {
            $node = $domElement;
          }
          else {
            $node = $this->createElement($domElement->tagName);
            $domElement->parentNode->appendChild($node);
          }
        }
        else {
          $node = $this->createElement($index);
          $domElement->appendChild($node);
        }
        $this->fromMixed($mixedElement, $node);
      }
    }
    else {
      $domElement->appendChild($this->createTextNode($mixed));
    }
  }
}
